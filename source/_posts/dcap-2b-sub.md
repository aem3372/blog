title: 直流电路分析2B法的程序设计解决方案
tags:
  - DCAP
  - 电路
id: 887
categories:
  - 算法/数据结构
date: 2013-06-09 01:49:32
---

直流电路分析中较为普通的一种方法是2B法，这种方法在手工计算上非常麻烦，而且不易编程求解。而回路电流法和结点电压法在手工计算和编程实现上都更为简单（这两种方法在电路分析软件上已经使用）。但是这并不影响我探究使用2B法编程，因为2B法反映的是一个非常普通的拓扑学运用。

<!--more-->

## 2B法

求下列电路图的各元器件电流电压值

[![dcap-sample](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-sample.jpg)](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-sample.jpg)

这个电路图有b=5条支路和n=4个节点

列出n-1 = 3个KCL（基尔霍夫电流方程）

$$
 \left\\{
\begin{aligned}
-I1-I5-I3 & = & 0 \\\\
 I1+I2    & = & 0 \\\\
 I5-I4    & = & 0
\end{aligned}
\right.
$$

列出b-(n-1) = 2个KVL（基尔霍夫电压方程）


$$
 \left\\{
\begin{aligned}
-U1+U2+U3 & = & 0 \\\\
-U3+U4+U5 & = & 0
\end{aligned}
\right.
$$

列出b = 5个CRL（元器件电压电流方程）

$$
 \left\\{
\begin{aligned}
U1 & = & 5 \\\\
U2 & = & I2 \* 1 \\\\
U3 & = & I3 \* 1 \\\\
U4 & = & I4 \* 2 \\\\
U5 & = & 10
\end{aligned}
\right.
$$
    
联立上述方程解得

$$
\left\\{
\begin{aligned}
I1 & = & -1 \\\\
I2 & = &  1 \\\\
I3 & = &  4 \\\\
I4 & = & -3 \\\\
I5 & = & -3 \\\\
U1 & = &  5 \\\\
U2 & = &  1 \\\\
U3 & = &  4 \\\\
U4 & = & -6 \\\\
U4 & = & -6
\end{aligned}
\right.
$$


## 实现思想

1. 电路图信息的储存形式及涉及的概念
2. 根据电路信息列出KCL方程
3. 根据电路信息列出KVL方程，这也是处理过程中比较耗时的部分（电路分析之所以大量使用结点电压法是因为结点电压法的KVL方程是0个，而且存在很好的矩阵运算来简化计算时间复杂度）
4. 根据电路信息列出CRL方程
5. 解方程

## 电路图信息的储存形式及涉及的概念

首先要用一张拓扑信息表储存读取到的最原始数据，表中的每一个部分实际上可以定义为如下结构体：

```cpp
struct Data{
char cls[3];   /*元器件符号*/
int   no,      /*元器件编号*/
      beg,     /*起始结点*/
      end;     /*终止结点*/
      /*起始结点到终止结点的方向为假定的正方向*/
float val,     /*元器件属性值*/
      other;   /*保留信息*/
};
```

计算中可能需要的几种储存形式：关联矩阵形式、回路矩阵形式（临接矩阵在描述多重图时存在效率上的瓶颈）

其他概念：生成树、哈密顿回路、连枝

## 根据电路信息列出KCL方程

利用电路拓扑信息可以直接填充一个关联矩阵，不难发现关联矩阵的每一行就是一个KCL的系数方程。以上述电路图为例，我们可以得到如下关联矩阵：

$$
\begin{bmatrix}
I1 & I2 & I3 & I4 & I5 \\\\
-1 &  0 & -1 &  0 & -1 \\\\
 1 &  1 &  0 &  0 &  0 \\\\
 0 & -1 &  1 &  1 &  0 \\\\
 0 &  0 &  0 & -1 &  1
\end{bmatrix}
$$

不难发现关联矩阵的每一行都是一个KCL方程且它们任意n-1个方程都是线性无关的，那么我们从中任选n-1个方程即可。

## 根据电路信息列出KVL方程

首先认识下回路矩阵。回路矩阵的每一行都是一个回路的记录，如果一条边是当前要记录的回路的一部分，则为1或-1（这取决于方向），否则为0

例如，图中电路对应的回路矩阵应为

$$
\begin{bmatrix}
V1 & V2 & V3 & V4 & V5 \\\\
-1 &  1 &  1 &  0 &  0 \\\\
 0 &  0 & -1 &  1 &  1 \\\\
-1 &  1 &  0 &  1 &  1
\end{bmatrix}
$$

同理，这个回路矩阵的每一行都是一个KVL方程，任意b-（n-1）个方程都是线性无关的，我们只需要其中的任意b-（n-1）个方程。因为完全构造这个矩阵较为复杂，所以我们只构造我们所需要的b-（n-1）行即可。

构造的过程，基于这样一种性质，一个多重图可以生成一些树，任取其中一颗生成树和它对应的余树，在生成树中加入任意一条连枝（余树中的边称为连枝）都可以构成唯一回路。因此构建回路矩阵的任务又化为了寻找生成树和余树。

就上述电路图，其中的一颗生成树和它的余数如下图所示：

[![dcap-shu](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-shu.jpg)](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-shu.jpg)

**生成树**

[![dcap-yushu](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-yushu.jpg)](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-yushu.jpg)

**它的余树**

假设我们得到了这样的一棵树以及它的余树，我们从余数中选择一条连枝加入到树中，想要判断它形成的环，我们需要在树的最基本结构中增加一个指向父节点的指针和一个表示当前层数的整数。这样我们在寻找它形成的环时，只要在树中找到加入的连枝的两个端点，然后一直向上返回，直到两个点汇合，期间经过的路径加上连枝本身就是一个环。

即树的一个结点可如下定义：

```cpp
struct Node{
    Node*  p;     /*指向父节点*/
    int    now;   /*当前层数*/
    int    no;    /*结点编号*/
    Node** next;  /*指向子结点列表*/
};
```

由于这种方法，需要K叉建树，耗时还不讨好。事实上我们只要在生成树的时候加以一定条件限制，就可以得到一个特殊的树，它非常适合这里的计算。而这条特殊的树其实就是哈密顿通路，毕竟一条链也是一棵树，而且这样的树具备了线性关系。因为它具备线性关系，所以我们也可以称呼它为线性表，正因如此，这就引发了添加连枝后，线性表中在这个两个端点之间的边加上连枝本身构成一个回路。

以之前的电路图为例，可以构造一个这样的特殊树以及它的余树：

[![dcap-tshu](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-tshu.jpg)](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-tshu.jpg)

[![dcap-tyushu](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-tyushu.jpg)](http://www.aemiot.com/wp-content/uploads/2013/06/dcap-tyushu.jpg)

假如从余树中选择0-2的连枝加入树中，则它与树中0-2部分构成了一个环。利用这点，我们就能够轻易的编程实现它。

## 根据电路信息列出CRL方程

每个元件的属性，其实以及在拓扑信息存在了，所以我们也可以直接根据拓扑信息填充它。

## 解方程

解保证有解的n元非齐次方程组，我们能够想到的两种在笔算上较为常用的方法，一种是利用克莱姆法则的方法，另一种是利用增广矩阵消元的方法。
第一种涉及到行列式的计算，可以通过产生全排列，根据行列式的定义来求解，时空复杂度均较高。
第二种其实在编程算法上称作高斯消元法，虽然它不是当前最好的解方程算法，但是在这里足够用了，因此我选择的是利用高斯消元法解决的方程求解。

既然所有步骤都已经分析过了，那么编程也就是可行的了。赞一个，神奇的编程，思考的乐趣~~
如有算法上的改进，欢迎交流。

依据上述解决方案得到的简易DCAP分析软件：[http://www.aemiot.com/simple-dcap.html](http://www.aemiot.com/simple-dcap.html "简易电路辅助分析软件|DCAP")
