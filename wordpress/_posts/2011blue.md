title: 2011第二届蓝桥杯C/C++程序设计本科B组省赛试题解题报告
tags:
  - '2011'
  - 初赛
  - 蓝桥杯
id: 379
categories:
  - 算法/数据结构
date: 2013-01-01 14:07:57
---

昨天从老师那边听来的蓝桥杯这个比赛，心血来潮，立即就把题目找来开始写了。
整张试卷难度系数不算太高，虽然我做的结果并不很理想，说它难度不高的原因是并没有像其他竞赛一样需要很多基础算法才能解答，不过作为初赛，这样的难度系数，让我深深感觉到了复赛的压力。

试卷一共7道填空题3道编程题，要求在4个小时内完成。
我从20:13开始打开试题，00:05交卷（呵呵，在我写的过程中2012-2013就这么跨过去了）
交卷后，找来答案，仔细核对后，我的成绩是74分。（满分100）
作为初赛，这样的成绩其实是非常不理想的。（日后我自个反省去。）

按照往常习惯，写完竞赛试卷后，写个解题报告吧。（可能不是最优解就是。）
试题，在文章底部以附件的形式放出，有兴趣做的，先试着写写再来看题解分享下吧。（竞赛中，程序写的可能没有很好的框架，大家见谅）

第一题
[toggle]
JC这个数组内容一看，真熟悉，这不是0-9的阶乘么（设计的很巧妙，因为只需要用到这些阶乘，事先算好存入数组，避免了重复计算）
按照题目意思，我们需要对数进行分解，获得它的每一位。
看到下面这个while循环的循环体，跟我平时写的将数分解的循环体真像。
猜测循环条件是 (x != 0) 或 (x)
重新阅读程序。
程序的实现：对于每一个三位数判断，取出一位数，到JC中找出它的阶乘加到sum，将sum和自身比较，如果相等就输出。
那么，可以断言，答案为 (x != 0) 或 (x)
[/toggle]

第二题
[toggle]
从 double t = x[i] - sum / (n-1); 可以看出
这时候的 sum 已经是除了一个数的和
再从 if(____) sum += s[j];
也会自然的想到应该填上 j != i
考试时，因为在这里顾忌时间不够，而且基本能断定答案是这个，对后面的程序只是粗略看了一下，和我的思路相仿就没去看具体实现了
现在，重新阅读程序。
依次假定每一个数是最离群的数，算出平均值
计算去掉的数与平均数的距离
如果距离大于当前已知的最大距离，更新相应数据（数和已知最大距离）
对每个数都判断完后，返回能产生最大距离的数
[/toggle]

第三题
[toggle]
粗略的看了一眼程序已知部分，发现没有循环，可想而知，这个一定是递归实现。
按递归思路看程序，循环体的第一条是递归边界控制语句。
第二条到第四条是典型的交换语句，那么在这里完成的就是首尾对调。
那么进一步调用自身，应该是调用原字符串去掉首尾后的子串。
那么填入 reverse_str(buf+1,n-2) 就行了
[/toggle]

第四题
[toggle]
这个按照十进制小数部分化其他进制看下去，非常通畅。
首先乘上要化的进制（例如要化成二进制，就乘2）
然后取出整数部分
那么很容易推断出两空分别是：
(int) dTestNo
iT[iNo] != 0 或 iT[iNo]
[/toggle]

第五题
[toggle]
从最后一句 strcpy(s,s2) 可以看出 s2 存放的是轮换后的结果
那么 s2 所需要的空间应该是 字符串长度 +1 （存放字符串结束符）
那么第一空应该是 sizeof(char)*(len+1)
从语句 q = s2 + n % len;
可以看出 q 定位了原字符串首字符在 s2 中的位置
在循环体中 *q++ = *p++; 这是复制的过程
再向下看，发现没有什么地方有写入 s2 的字符串终止符 '\0'
猜测，第二空是 '\0'
按照这个猜想
循环体内 if语句 实现的就是，如果 s2 到达尾部，写入字符串终止符''，并且将将要写的位置定位到 s2 头部
那么可以断言 第二空答案就是 ''
综上所述，上面两空答案分别是：
sizeof(char)*(len+1)
'\0'
[/toggle]

第六题
[toggle]
说实在的，考试时，我忘记了 strstr() 是什么函数了。（罪过罪过~~）
考试时，我是这样写的
首先看到
char t = _____;
sa[i+j] = 0;
然后又看到
sa[i+j] = t;
我就想到我们编程时惯用的手法，先保存它，然后修改它，最后还原它、
没办法，有函数忘了，只能这么写了，我就推测第一空是 sa[i+j]
第二空么，我注意到了返回值是 n ，那么 n 就应该是中了的数目
纵观整个程序，愣是没发现，有什么地方对 n 进行了赋值
再看到 if(j &gt; n) 我又想到我们编程的惯用手法了，n 保存的应该是当前已知的最大数目，如果找到更大的就更新它
那么可以推测 j 就是当前的数目，那么自然而然，我就猜到第二空是 n = j
于是，我两空的答案就是：
sa[i+j]
n = j
事实证明，我猜对了。
具体实现方法，暂时还没看。先放着，日后更新此文章时，给出完整编程思路，而不是猜测性思路。
[/toggle]

第七题
[toggle]
表示概率忘的很彻底，没看懂。
答案暂时还没看，也先放着，日后更新文章时，给出解析。
[/toggle]

第八题
[toggle]
终于来了，编程题
不得不说，这题水的很。
简单说下，就直接我写的贴代码吧。
我的方法就是建立一个矩阵，然后写入一个数后更新坐标，使他定位到下一个要写的位置
可以写入顺序总是 向右 &gt;&gt; 向左下 &gt;&gt; 向上
并且从最开始连续写入 n个数开始，每次要连续写入的数都少了 1个
也就是说连续写入的数分别 n n-1 n-2 ...个
那么在一个循环里，每次循环完成这三个步骤，注意控制好循环就行
代码如下：

[code lang="cpp"]
#include &lt;stdio.h&gt;
int main(void)
{
	int i,j,n,s,x=0,y=0,num=1;
	int bar[20][20]={{0}};
	scanf(&quot;%d&quot;,&amp;n);
	s=n+1;
	while(1)
	{
		--s;
		if(s==0) break;
		for(i=0; i&lt;s; ++i)
		{
			bar[x][y] = num++;
			if(i != s-1) ++y;
			else
				++x,--y;
		}
		--s;
		if(s==0) break;
		for(i=0; i&lt;s; ++i)
		{
			bar[x][y] = num++;
			if(i != s-1) ++x,--y;
			else
				--x;
		}
		--s;
		if(s==0) break;
		for(i=0; i&lt;s; ++i)
		{
			bar[x][y] = num++;
			if(i != s-1) --x;
			else
				++y;
		}
	}
	for(i=0; i&lt;n; ++i)
	{
		for(j=0; j&lt;n-i; ++j)
			printf(&quot;%4d&quot;,bar[i][j]);
		printf(&quot;\n&quot;);
	}
	return 0;
}
[/code]

[/toggle]

第九题
[toggle]
表示突然抽风了，感觉这有点类似背包问题，又有点不像。不过，具体方案，考试时居然没想到。
现在时间有限，暂时也先搁着吧，日后更新再重做此题。
[/toggle]

第十题
[toggle]
这题就是考模拟。
它有啥要求，对着写就好了，不难。
（话说，我之前写的密码管理器的加密部分，比这东西复杂多了）
我的代码如下：

[code lang="cpp"]
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void)
{
	char abc[2][27] = {&quot;abcdefghijklmnopqrstuvwxyz&quot;,{0}},temp[25];
	char bar[5][5],key[26],str[51],res[51],a,b;
	char *p;
	int keylen,i,j,pos=0,abc_pos=0,x1,x2,y1,y2;
	scanf(&quot;%s&quot;,key);
	keylen = strlen(key);
	for(i=0; i&lt;keylen; ++i)
	{
		char t = key[i];
		temp[pos++] = t;
		abc[1][t-'a'] = 1;
	}
	while(1)
	{
		if(pos == 25)	break;
		if(abc[1][abc_pos] == 0) temp[pos++] = abc[0][abc_pos];
		abc_pos++;
	}
	pos=0;
	for(i=0; i&lt;5; ++i)
		for(j=0; j&lt;5; ++j)
			bar[i][j] = temp[pos++];
	//密码表设置完成，开始获取加密数据并加密
	scanf(&quot;%s&quot;,str);
	pos = 0;
	abc_pos = 0;
	while(1)
	{
		if(str[abc_pos] != 0 &amp;&amp; str[abc_pos+1] != 0)
		{
			a = str[abc_pos++];
			b = str[abc_pos++];
		}
		else
			break;
		x1 = x2 = y1 = y2 = -1;
		for(i=0; i&lt;5; ++i)
			for(j=0; j&lt;5; ++j)
				if(bar[i][j] == a)
					x1 = i,y1 = j;
		for(i=0; i&lt;5; ++i)
			for(j=0; j&lt;5; ++j)
				if(bar[i][j] == b)
					x2 = i,y2 = j;
		if(x1 == -1 || x2 == -1 || y1 == -1 || y2 == -1)	//存在一个密码表中找不到的
		{
			res[pos++] = a;
			res[pos++] = b;
		}
		else if(x1 == x2 || y1 == y2)//都在密码表中找到,但是同行或同列
			{
				res[pos++] = b;
				res[pos++] = a;
			}
			else //都在密码表中找到，不同行或不同列
			{
				res[pos++] = bar[x1][y2];
				res[pos++] = bar[x2][y1];
			}
	}
	if(strlen(str)%2 == 1)
		res[pos++] = str[strlen(str)-1];
	res[pos] = 0;
	printf(&quot;%s\n&quot;,res);
	return 0;
}
[/code]

[/toggle]

[note]
<span style="color: #ff6600;"><big>**试题需要使用PDF阅读器打开**</big></span>
[/note]

试题下载

*   [download link="http://www.aemiot.com/download/2011第二届蓝桥杯C程序设计省赛试题.rar"]<span style="color: #050505;"><big>**  本地下载**</big></span>[/download]
[warning]
作者:Aem
本文版权归作者和www.aemiot.com共有，未征得作者本人同意之前，请勿将本文内容用于任何商业用途。 欢迎非商业用途转载，但请在明显位置注明本文作者和出处链接，否则我们保留追究法律责任的权利。
[/warning]