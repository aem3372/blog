title: 2013第四届蓝桥杯C/C++程序设计本科B组省赛试题下载及解题报告（更新至第九题）
tags:
  - '2013'
  - 下载
  - 第四届
  - 蓝桥杯
  - 试题
  - 题解
id: 797
categories:
  - 算法/数据结构
date: 2013-05-11 16:16:36
---

哎，这次比赛，我纯酱油了....考试的时候短路的很...心态不正必败啊。

# 第一题

[toggle]
很简单的一道题，对于有过训练的ACMer应该可以速度解决的。
对于不常参加训练的就简单说下，注意闰年不是简单判断4的倍数。
ps：闰年，四年一闰，百年不闰，四百又闰。
计算出来的答案是： 1799－07－16
用于计算的代码（比赛的时候就别写成类还重载操作符了，下面这是我回来后写的）：

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

const int MonJC[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
const int TMonJC[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};

class Date{
friend Date operator- (Date T,unsigned int n);
friend Date operator+ (Date T,unsigned int n);
friend istream&amp; operator&gt;&gt; (istream&amp; is,Date T);
friend ostream&amp; operator&lt;&lt; (ostream&amp; os,Date T);
public:
	Date() {}
	Date(int y,int m,int d):year(y),month(m),day(d) {}
	bool check() //判断当前是否是闰年
	{
	    if(!(year%400)) return true;//能被400整除
        if(!(year%4))
        {
            if(!(year%100))
                return false;
            else
                return true;
        }
        else
            return false;
	}
	void Ty()
	{
		 --year;
	}
	void Tm()
	{
		if(month==1)
		{
			month = 12;
			Ty();
		}
		else
			--month;
	}
	void Td()
	{
		if(day==1)
		{
			Tm();
			if(check()) //闰年
				day = TMonJC[month];
			else
				day = MonJC[month];
		}
		else
			--day;
	}
	void Ay()
	{
		++year;
	}
	void Am()
	{
		if(month==12)
		{
			month = 1;
			Ay();
		}
		else
			++month;
	}
	void Ad()
	{
		if(month!=2)
		{
			if(day==MonJC[month])
			{
				day = 1;
				Am();
			}
			else
				++day;
		}
		else
			if(check()) //闰年
			{
				if(day==TMonJC[month])
				{
					day = 1;
					Am();
				}
				else
					++day;
			}
			else
			{
				if(day==MonJC[month])
				{
					day = 1;
					Am();
				}
				else
					++day;
			}
	}
private:
	int year,month,day;
};

Date operator- (Date T,unsigned int n)
{
	while(n--)
		T.Td();
	return T;
}

Date operator+ (Date T,unsigned int n)
{
	while(n--)
		T.Ad();
	return T;
}

istream&amp; operator&gt;&gt; (istream&amp; is,Date T)
{
	char t;
	is &gt;&gt; T.year &gt;&gt; t &gt;&gt; T.month &gt;&gt; t &gt;&gt; T.day;
	return is;
}

ostream&amp; operator&lt;&lt; (ostream&amp; os,Date T)
{
	cout &lt;&lt; T.year &lt;&lt; '/';
	if(T.month&lt;10)
		cout &lt;&lt; 0 &lt;&lt; T.month &lt;&lt; '/';
	else
		cout &lt;&lt; T.month &lt;&lt; '/';
	if(T.day&lt;10)
		cout &lt;&lt; 0 &lt;&lt; T.day;
	else
		cout &lt;&lt; T.day;
	//printf(&quot;%02d/%02d/%02d&quot;,T.year,T.month,T.day);
	return os;
}

int main(void)
{
    Date *p = new Date();
	Date base(1777,4,29);
    cout &lt;&lt; base+8113 &lt;&lt; endl;
	return 0;
}
[/code]

[/toggle]

# 第二题

[toggle]
这没啥好说的，暴力之，全排列算法都不用，直接上五重循环就可以了。
计算出的答案是: 142
用于计算的代码：
[code lang="c"]
#include&lt;stdio.h&gt;
int main()
{
    int a,b,c,d,e;
    int count = 0;
    for(a=1; a&lt;=9; ++a)
        for(b=1; b&lt;=9; ++b)
            for(c=1; c&lt;=9; ++c)
                for(d=1; d&lt;=9; ++d)
                    for(e=1; e&lt;=9; ++e)
                        if(a!=b &amp;&amp; a!=c &amp;&amp; a!=d &amp;&amp; a!=e &amp;&amp;
                           b!=c &amp;&amp; b!=d &amp;&amp; b!=e &amp;&amp;
                           c!=d &amp;&amp; c!=e &amp;&amp;
                           d!=e &amp;&amp;
                           (a*10+b)*(c*100+d*10+e) == (a*100+d*10+b)*(c*10+e))
                                    ++count;
    printf(&quot;%d&quot;,count);
}

[/code]
[/toggle]

# 第三题

[toggle]
这题么，我考试的时候抽风了，绝对是抽风了（大家都说蓝桥是水，我压根就没按平时打OJ比赛的思路去想）....居然会去想排列组合了。

回去一看，不就是个递推么= =（我还记得原来还做过个锁妖塔的题，这题就是那货的精简版啊，T_T）。

从题意知，假定先迈的是左脚，那么到达一层右脚落下的情况是0种，到一层左脚落下的情况是1种，到达二层左脚落下的情况是1种，到达二层右脚落下的情况是1种，之后到达第N层左脚落下的情况数是第N-1层右脚落下的情况数加上N-2层右脚落下的情况数，第N层右脚落下的情况数是第N-1层左脚落下的情况数加上N-2层左脚落下的情况数（这是基于第N层右脚落下，只能是从N-1层迈右脚走1或者从N-2层迈右脚走2的事实得到的结论）。
递推公式为：
arr[0][i] = arr[1][i-1] + arr[1][i-2]
arr[1][i] = arr[0][i-1] + arr[0][i-2]
计算结果为： 51167078
用于计算的代码：
[code lang="c"]
#include &lt;stdio.h&gt;
int main()
{
	int i;
	int arr[2][50];
	/*[  ][N] 第N层状况*/
	/*[0][N] 右脚落下，接下来迈出左脚*/
	/*[1][N] 左脚落下，接下来迈出右脚*/
	arr[0][1] = 0;
	arr[1][1] = 1;
	arr[0][2] = 1;
	arr[1][2] = 1;
	for(i=3; i&lt;50; ++i)
	{
		arr[0][i] = arr[1][i-1] + arr[1][i-2];
		arr[1][i] = arr[0][i-1] + arr[0][i-2];
	}
	printf(&quot;%d\n&quot;,arr[0][39]);
	return 0;
}

[/code]
[/toggle]

# 第四题

[toggle]
模拟题目给出的连分式运算（有兴趣的朋友可以去试试其他的办法，比如利用（根号5-1）/2 - 1 去计算）
为了简单处理，用java的大数类写吧（搞竞赛不好好利用下java的大数，实在是浪费资源啊）。
ps：考试的时候，我那机子不知道怎么回事，java的编译器各种抽风
因为不知道要计算到多少次才能到精度100...干脆就按OI的办法...10000-100000次吧...开个黑框让它慢慢算，反正比赛时间长，不怕它算不出来
计算小数点后101位: 0.61803 39887 49894 84820 45868 34365 63811 77203 09179 80576 28621 35448 62270 52604 62818 90244 97072 07204 18939 11374 8
四舍五入后答案为： 0.61803 39887 49894 84820 45868 34365 63811 77203 09179 80576 28621 35448 62270 52604 62818 90244 97072 07204 18939 11375
用于计算的代码：
[code lang="java"]
import java.util.Scanner;
import java.math.*;
import java.util.*;
public class Welcome
{
	public static void main(String[] args)
	{
		  int JD = 101;
		  BigDecimal b1 = new BigDecimal(&quot;1.000000&quot;);
      		  BigDecimal b2 = new BigDecimal(&quot;1.000000&quot;);
      		  for(int i = 0; i &lt; 10000; ++i)
		 {
		  b2 = b1.divide(b2.add(new BigDecimal(&quot;1.0000000&quot;)),10000,BigDecimal.ROUND_HALF_UP);
		}
		System.out.println(b2.toString().substring(0,JD+2));
	}
}
[/code]
[/toggle]

# 第五题

[toggle]
很简单，不多说。
答案： *haystack++ != *needle++
[/toggle]

# 第六题

[toggle]
依然简单，分也少。
答案： p++
[/toggle]

# 第七题

[toggle]

# 解题思路

水题，遍历即可。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
using namespace std;
int flag[100011] = {0};
int main()
{
	string temp;
	int T;
	cin &gt;&gt; T;
	getline(cin,temp); //读掉换行符
	int chong=0,que=0;
	int min=100000,max=0;
	while(T--)
	{
		int id;
		getline(cin,temp);
		istringstream is(temp);
		while(is &gt;&gt; id)
		{
			//cout &lt;&lt; id &lt;&lt; endl;
			max = id&gt;max?id:max;
			min = id&lt;min?id:min;
			if(flag[id])
				chong = id;
			flag[id] = 1;
		}
	}
	for(int i=min+1; i&lt;max; ++i)
		if(!flag[i])
		{
			que = i;
			break;
		}
	cout &lt;&lt; que &lt;&lt; &quot; &quot;&lt;&lt; chong  &lt;&lt; endl;
	return 0;
}
[/code]
[/toggle]

# 第八题

[toggle]

# 解题思路

见代码注释。

# 我的代码

[code lang="cpp"]
/*
12345678
o******o 
*o*o***o   1   o**oo**o 
**o****o   2   *o*oo**o
***o***o   3   **ooo**o
***o**o*   4   ****o**o
***o*o**   5   ***o***o
***oo***   6   ***ooo*o
           7   ***oo*oo
           8   ***oo***
1 4 5 8
(4-1)+(8-5)    (5-4)+(8-1)
1 6 8 11

*/

//一定有偶数个不同
//找出开始和目标中不同的对,最短的移动方案就很显而易见，就是依次将临近的不同对消除。
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
int main(int argc, char const *argv[])
{
	string start;
	string aim;
	vector&lt;int&gt; v;
	int sum = 0;
	cin &gt;&gt; start &gt;&gt; aim;
	for(int i=0; i&lt;(int)aim.size(); ++i)
		if(aim[i] != start[i])
			v.push_back(i);
	for(int i=0; i*2&lt;(int)v.size(); ++i)
		sum += v[2*i+1] - v[2*i];
	cout &lt;&lt; sum &lt;&lt; endl;
	return 0;
}
[/code]
[/toggle]

<h>第九题</h1>
[toggle]

# 解题思路

暴力,注意维度。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
using namespace std;

int ans = 0;
int flag[10];
void dfs(int a,int b,int N)
{
	int ac,bc;
	ac = a;
	bc = b;
	if(a &amp;&amp; b &amp;&amp; b%(N-a)==0)
	{
		int tflag[10] = {0};
		int c = b/(N-a);
		int cc = c;
		int ok = 1;
		int sum = 0;
		while(cc)
		{
			++sum;
			if(cc%10==0 || flag[cc%10] || tflag[cc%10])
				ok = 0;
			else
				tflag[cc%10] = 1;
			cc /= 10;
		}
		while(ok &amp;&amp; ac)
		{
			++sum;
			ac /= 10;
		}
		while(ok &amp;&amp; bc)
		{
			++sum;
			bc /= 10;
		}
		if(ok &amp;&amp; sum!=9)
			ok = 0;
		if(ok)
		{
			++ans;
			//cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;
			//system(&quot;pause&quot;);
		}
	}
	for(int i=1; i&lt;=9; ++i)
	{
		if(!flag[i])
		{
			flag[i] = 1;
			dfs(a,b*10+i,N);
			flag[i] = 0;
		}
	}
}

int main()
{
	int N;
	cin &gt;&gt; N;
	for(int i=1; i&lt;N ; ++i)
	{
		memset(flag,0,sizeof(flag));
		int ac = i;
		int len = 0;
		int ok = 1;
		while(ac &amp;&amp; ok)
		{
			++len;
			if(flag[ac%10] || ac%10==0)
				ok = 0;
			else
				flag[ac%10] = 1;
			ac /= 10;
		}
		if(ok)
			dfs(i,0,N);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	//cout &lt;&lt; clock()/CLOCKS_PER_SEC &lt;&lt; endl;
	return 0;
}
[/code]
[/toggle]

# 第十题（暂未更新）

# 试题下载

[download link="http://www.aemiot.com/download/2013第四届蓝桥杯C程序设计本科B组省赛试题.rar"]<span style="color: #050505;"><big>**&nbsp;&nbsp;&nbsp;本地下载**</big></span>[/download]
[warning]
作者:Aem
本文版权归作者和www.aemiot.com共有，未征得作者本人同意之前，请勿将本文内容用于任何商业用途。 欢迎非商业用途转载，但请在明显位置注明本文作者和出处链接，否则我们保留追究法律责任的权利。
[/warning]