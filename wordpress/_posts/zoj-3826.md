title: '解析EON|Hierarchical Notation|ZOJ 3826|2014 Regional 牡丹江'
id: 1440
categories:
  - 算法/数据结构
date: 2015-05-09 22:19:44
tags:
---

# 题目

[Hierarchical Notation](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=5380 "http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=5380")

# 题目大意

解析一个EON格式的字符串，然后查询内容。

# 解题思路

EON格式是树状结构。扫描字符串，根据状态转换解析各个node。

[code lang="cpp"]
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;stack&gt;
#include &lt;iostream&gt;
using namespace std;

#define T_KEY 0
#define T_VALUE 1
#define T_ARRAY 2

struct Node
{
	int st;
	int ed;
	int type;
	Node* ft;
	vector&lt;Node*&gt; lt;
}*root;

const char* pjson;

void parse(const string&amp; json)
{
	root = new Node();
	root-&gt;st = 0;
	root-&gt;ed = 0;
	Node* now = root;
	Node* lastS = NULL;
	stack&lt;Node*&gt; Qdb;
	int flag = 0; //标记&quot;&quot;内外
	int p = 0;
	while(p&lt;json.size())
	{
		if(json[p] == '{')
		{
			Node* t = new Node();
			t-&gt;st = p;
			t-&gt;ft = now;
			Qdb.push(t);
			t-&gt;type = T_ARRAY;
			now-&gt;lt.push_back(t);
			now = t;
		}
		if(json[p] == '}')
		{
			Qdb.top()-&gt;ed = p;
			Qdb.pop();
			if(!Qdb.empty())
				now = Qdb.top();
		}
		if(json[p] == ':')
		{
			now = lastS;
		}
		if(json[p] == '\&quot;')
		{
			if(flag) //string结束
			{
				lastS-&gt;ed = p;
				if(lastS-&gt;type == T_VALUE)
					now = now-&gt;ft;
				flag = 0;
			}
			else //string开始
			{
				Node* t = new Node();
				lastS = t;
				t-&gt;st = p;
				t-&gt;ft = now;
				if(now-&gt;type == T_KEY)
					t-&gt;type = T_VALUE;
				else
					t-&gt;type = T_KEY;
				now-&gt;lt.push_back(t);
				flag = 1;
			}
		}
		++p;
	}
}

Node* findNode(Node* now, const string&amp; key)
{
	for(int i=0; i&lt;now-&gt;lt.size(); ++i)
	{
		if(now-&gt;lt[i]-&gt;type == T_ARRAY)
		{
			Node* t = findNode(now-&gt;lt[i],key);
			if(t != NULL)
				return t;
		}
		if(now-&gt;lt[i]-&gt;type == T_KEY)
		{
			if(!strncmp(key.c_str(), pjson+now-&gt;lt[i]-&gt;st, key.size()))
				return now-&gt;lt[i];
		}
	}
	return NULL;
}

string query(const string&amp; json, const string&amp; q)
{
	Node* now = root;
	int flag = 0;
	int p = 0;
	int st = 0;
	while(p &lt; q.size())
	{
		if (q[p] == '\&quot;')
		{
			if (flag) //string结束
			{
				now = findNode(now, q.substr(st, p - st + 1));
				if (now == NULL)
					return &quot;Error!&quot;;
				flag = 0;
			}
			else //string开始
			{
				st = p;
				flag = 1;
			}
		}
		++p;
	}
	return 	json.substr(now-&gt;lt[0]-&gt;st, now-&gt;lt[0]-&gt;ed - now-&gt;lt[0]-&gt;st + 1);
}

void clear(Node* now)
{
	for(int i=0; i&lt;now-&gt;lt.size(); ++i)
	{
		clear(now-&gt;lt[i]);
	}
	clear(now);
}

int main()
{
	int T;
	cin &gt;&gt; T;
	while(T--)
	{
		string json;
		cin &gt;&gt; json;
		pjson = json.c_str();
		parse(json);
		//db(json, root-&gt;lt[0]);
		int Q;
		cin &gt;&gt; Q;
		while(Q--)
		{
			string key;
			cin &gt;&gt; key;
			cout &lt;&lt; query(json,key) &lt;&lt; endl;
		}
	}
}
/*
	1
	{&quot;a&quot;:{&quot;b&quot;:&quot;b&quot;,&quot;f&quot;:{&quot;c&quot;:{&quot;a&quot;:{&quot;b&quot;:&quot;s&quot;,&quot;v&quot;:&quot;k&quot;}},&quot;sdf&quot;:&quot;r&quot;}}}

	8
	&quot;a&quot;
	&quot;b&quot;
	&quot;b&quot;.&quot;b&quot;
	&quot;a&quot;.&quot;f&quot;
	&quot;a&quot;.&quot;f&quot;.&quot;c&quot;
	&quot;a&quot;.&quot;f&quot;.&quot;c&quot;.&quot;a&quot;.&quot;b&quot;
	&quot;a&quot;.&quot;f&quot;.&quot;c&quot;.&quot;a&quot;.&quot;v&quot;
	&quot;a&quot;.&quot;f&quot;.&quot;sdf&quot;
*/
[/code]