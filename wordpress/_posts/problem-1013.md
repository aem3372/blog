title: '使用数论知识消除模拟|HDU-Problem-1013'
tags:
  - '2013'
  - 数字根
  - 数论
id: 676
categories:
  - 算法/数据结构
date: 2013-02-25 23:24:17
---

题目：杭电Problem-1013 [Digital Roots](http://acm.hdu.edu.cn/showproblem.php?pid=1013)

题目简述：一个数各进制位之和是一位数那么这个和就是这个数的根，如果各进制之和不是一位数，则这个和的根就是这个数的根。求一些给定数的根。

思路：（这是我的解题思路，也是一般的模拟方法，其实这道题利用数论可以无限简化，等说完一般的，我再贴出某大神的**数论式解法**）以字符串读入（数据范围很大）,计算出各进制位之和（各进制位之和用long int储存就可以了，因为一个1000位的数字各进制数之和最大也就9000），如果是个位数就输出，如果不是就再求各进制位之和来求根。

我的代码：
[code lang="cpp"]
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

long ReX(char n[])
{
    long x,i,v;
    while(1)
    { 
        x=0,i=0;
        while( n[i]!='&#92;&#48;' )
            x += n[i++]-'0';
        if(x&gt;=0&amp;&amp;x&lt;=9) return x;
        v=sprintf(n,&quot;%ld&quot;,x);
        n[v]= '&#92;&#48;'; 
    }
}
int main(void)
{
    char t[10000]; /*这里我一开始只开了200，总是不能AC，找了很久，才发现数组开小了，鄙视下题目不给数据范围*/
    while(gets(t),t[0]!='0')
        printf(&quot;%ld\n&quot;,ReX(t));
    return 0;
}
[/code]

&nbsp;

&nbsp;
接下来，介绍下某大神的极简代码：

[code lang="cpp"]
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    int a,c;
    for(;scanf(&quot;%1d&quot;,&amp;a),a&gt;0;printf(&quot;%d\n&quot;,--a%9u+1))
        while((c=getchar())-48u&lt;10)
            a+=c-48;
    return 0;
}
[/code]

非常简单吧，我刚开始看到这段代码都震撼了（感叹！原来还能这样）。

关于这段代码之所以能够AC，我就引用下“逆水行舟”这位杭电的ACMer的解说吧。

[note]
下面第四点是错误的，这里的U标识是必要的，因为读到回车（10）时，10-48<10会继续循环，而加上U变为10-48U时运算结果是一个非常大的数因而跳出循环。
[/note]

1.一位数模9是它本身(9除外);整十数模9是它十位的数字(90除外);整百数摸9是它百位的数字(900除外)......

2.对于一个一般的数,可以分拆成几个10的幂的和;一般的数模9的结果,实质就是题目所描述的"数字根"(9的倍数除外).

3.反复提到9的倍数除外,那这个除外的结果是什么?想一下就清楚.所以楼主先--a再%9最后+1就是在处理这种情况

<del datetime="2013-02-25T15:16:35+00:00">4.数字后面跟u后缀代表无符号整数,至于9啊48啊还要加这个，那是楼主在炫耀他的代码能力，大家可无视之</del>

5.最后提醒 48 == ‘0’

[warning]
作者:Aem
本文版权归作者和www.aemiot.com共有，未征得作者本人同意之前，请勿将本文内容用于任何商业用途。 欢迎非商业用途转载，但请在明显位置注明本文作者和出处链接，否则我们保留追究法律责任的权利。
[/warning]