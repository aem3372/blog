title: ACM集训队2014上半年第一次练习解题报告
tags:
  - ACM
  - 解题报告
id: 1252
categories:
  - 算法/数据结构
date: 2014-03-02 16:31:09
---

题目以及所有源码，在博文尾部附有下载链接。

[toggle title="第一题题解"]

# 解题思路

按照题目图片中的xyz轴建立三维空间坐标系,给各方块编号，从[0][0][0]-[1][1][1],每次旋转x,y或z实质上就是对固定x=1,y=1或z=1构成的平面顺时针旋转。
这次旋转具体可拆分为2步，首先是小方块自转，方块位置轮换。按照这个思路即可完成模拟从而AC。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
const int g = 0;
const int r = 1;
const int w = 2;
const int b = 3;
const int h = 4;
const int y = 5;
const int hide = 6;
struct T
{
	/* data */
	int t,b,l,r,f,u;
	void set(int at,int ab,int al,int ar,int af,int au)
	{
		t = at;
		b = ab;
		l = al;
		r = ar;
		f = af;
		u = au;
	}
	void rotate_x()
	{
		int temp;
		temp = t;
		t = l;
		l = b;
		b = r;
		r = temp;
	}
	void rotate_y()
	{
		int temp;
		temp = f;	
		f = b;
		b = u;
		u = t;
		t = temp;
	}
	void rotate_z()
	{
		int temp;
		temp = f;
		f = r;	
		r = u;
		u = l;
		l = temp;
	}
};

T A[2][2][2];

//void set(int at,int ab,int al,int ar,int af,int au);

void def()
{
	A[0][0][0].set(hide,y,h,hide,hide,b);
	A[0][1][0].set(hide,y,hide,r,hide,b);
	A[1][1][0].set(hide,y,hide,r,g,hide);
	A[1][0][0].set(hide,y,h,hide,g,hide);

	A[0][0][1].set(w,hide,h,hide,hide,b);
	A[0][1][1].set(w,hide,hide,r,hide,b);
	A[1][1][1].set(w,hide,hide,r,g,hide);
	A[1][0][1].set(w,hide,h,hide,g,hide);
}

void opertor_x()
{
	A[1][1][0].rotate_x();
	A[1][0][0].rotate_x();
	A[1][0][1].rotate_x();
	A[1][1][1].rotate_x();
	T temp = A[1][1][1];
	A[1][1][1] = A[1][0][1];
	A[1][0][1] = A[1][0][0];
	A[1][0][0] = A[1][1][0];
	A[1][1][0] = temp;
}

void opertor_y()
{
	A[0][1][0].rotate_y();
	A[1][1][0].rotate_y();
	A[1][1][1].rotate_y();
	A[0][1][1].rotate_y();
	T temp = A[0][1][1];
	A[0][1][1] = A[1][1][1];
	A[1][1][1] = A[1][1][0];
	A[1][1][0] = A[0][1][0];
	A[0][1][0] = temp;
}

void opertor_z()
{
	A[0][0][1].rotate_z();
	A[0][1][1].rotate_z();
	A[1][1][1].rotate_z();
	A[1][0][1].rotate_z();
	T temp = A[1][0][1];
	A[1][0][1] = A[1][1][1];
	A[1][1][1] = A[0][1][1];
	A[0][1][1] = A[0][0][1];
	A[0][0][1] = temp;
}
void print(int c)
{
	switch(c)
	{
		case 0: cout &lt;&lt; &quot;绿&quot;; break;
		case 1: cout &lt;&lt; &quot;红&quot;; break;
		case 2: cout &lt;&lt; &quot;白&quot;; break;
		case 3: cout &lt;&lt; &quot;蓝&quot;; break;
		case 4: cout &lt;&lt; &quot;橙&quot;; break;
		case 5: cout &lt;&lt; &quot;黄&quot;; break;
		case 6: break;
	}
}

int main(int argc, char const *argv[])
{
	/* code */
	def();
	string str;
	cin &gt;&gt; str;
	for(int i=0; i&lt;str.size(); ++i)
	{
		if(str[i]=='x')
			opertor_x();
		if(str[i]=='y')
			opertor_y();
		if(str[i]=='z')
			opertor_z();
	}
	print(A[1][1][1].f); 
	cout &lt;&lt; &quot; &quot;;
	print(A[1][1][1].r);
	cout &lt;&lt; &quot; &quot;;
	print(A[1][1][1].t); 
	cout &lt;&lt; endl;	
	return 0;
}
[/code]
[/toggle]

[toggle title="第二题题解"]

# 解题思路

文件操作+排序+遍历

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

struct recode
{
	/* data */
	string code;
	string name;
	int unit;
	int num;
	long money;
};

vector&lt;recode&gt; v;

bool compare(recode a,recode b)
{
	if(a.code != b.code)
	{
		return a.code &lt; b.code;
	}
	return a.money &gt; b.money;
}

string max_code;
long long max_money;

int main(int argc, char const *argv[])
{
	/* code */
	ifstream is(&quot;A_01_in.dat&quot;);
	ofstream os(&quot;A_01_out.dat&quot;);
	int n;
	recode t;
	string st;
	int it;
	long long lt;
	while(is &gt;&gt; n)
	{
		v.clear();
		for(int i=0; i&lt;n; ++i)
		{
			is &gt;&gt; st;
			t.code = st;
			is &gt;&gt; st;
			t.name = st;
			is &gt;&gt; it;
			t.unit = it;
			is &gt;&gt; it;
			t.num = it;
			is &gt;&gt; lt;
			t.money = lt;
			v.push_back(t);
		}
		sort(v.begin(),v.end(),compare);
		int t_money = 0;
		for(int i=0; i != v.size(); ++i)
		{
			if(i==0)
			{
				t_money = v[i].money;
				max_code = v[i].code;
				max_money = t_money;
			}
			else
			{
				if(v[i].code == v[i-1].code)
				{
					t_money += v[i].money;
				}
				else
				{
					t_money = v[i].money;
				}
				if(t_money &gt; max_money)
				{
					max_code = v[i].code;
					max_money = t_money;
				}
			}
		}
		for(int i=0; i != v.size(); ++i)
		{
			os &lt;&lt; v[i].code &lt;&lt; &quot;,&quot;
				 &lt;&lt; v[i].name &lt;&lt; &quot;,&quot;
				 &lt;&lt; v[i].unit &lt;&lt; &quot;,&quot;
				 &lt;&lt; v[i].num  &lt;&lt; &quot;,&quot;
				 &lt;&lt; v[i].money&lt;&lt; endl;
		}
		os &lt;&lt; max_code &lt;&lt; endl;
	}
	is.close();
	os.close();
	return 0;
}
[/code]
[/toggle]

[toggle title="第三题题解"]

# 解题思路

合理枚举，适当优化。为了避免输出重复的一对,例如<a,b> **，可以使用标志数组，或者是强加次序(即假定a小于b或a大于b)。我的代码采用的是标志数组方案。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
using namespace std;
int flag[5002] = {0};
int main()
{
	for(int a = 1; a &lt; 5000; ++a)
	{
		if(flag[a]) continue;
		int sum = 0;
		for(int i=1; i&lt;a; ++i)
			if(a%i == 0)
				sum += i;
		if (a==sum || sum &gt; 5000)
			continue;
		else
		{
			int t = 0;
			for(int i=1; i&lt;sum; ++i)
				if(sum%i == 0)
					t += i;
			if(t == a)
			{
				flag[a] = flag[sum] = 1;
				cout &lt;&lt; '(' &lt;&lt; a &lt;&lt; ',' &lt;&lt; sum &lt;&lt; ')' &lt;&lt; endl;
			}
		}
	}
	return 0;
}
[/code]
[/toggle]

[toggle title="第四题题解"]

# 解题思路

贪心。可以参考<a href="http://www.aemiot.com/jxustnc-2013-xss0.html" title="2013江西理工大学软件学院ACM新生热身赛题解" target="_blank">2013江西理工大学软件学院ACM新生热身赛题解</a>第六题和[删除数字问题的数学证明](http://www.aemiot.com/delete-number-problem.html "删除数字问题的数学证明")，不过这里因为数据较大的问题，要使用long long类型或者干脆当字符处理。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

char del(char num[], int len)
{
	for(int i=0; i&lt;len-1; ++i)
		if(num[i]&lt;num[i+1])
		{	
			char t = num[i];
			strcpy(num+i,num+1+i);
			return t;
		}
	char t = num[len-1];
	num[len-1] = '&#92;&#48;';
	return t;
}

int main()
{
	long long n = 9208134618538LL;
	char num[20];
	sprintf(num,&quot;%lld&quot;,n);
	for(int i=0; i&lt;10; ++i)
	{
		cout &lt;&lt; del(num,strlen(num)) &lt;&lt; &quot;,&quot;
		     &lt;&lt; num &lt;&lt; endl;
	}
	return 0;
}
[/code]
[/toggle]

[toggle title="第五题题解"]

# 解题思路

排列组合或递推。(其实这题是HDU-2190 悼念512汶川大地震遇难同胞——重建希望小学)

**排列组合**:
res = C[k,0]*2^0 + C[(k-1),1]*2^1 + C[(k-2),2]*2^2 + ... + C[(k-k/2),k/2]*2^(k/2)
公式中除法为整除。
公式可解释为：在k*3的格子中放n个2*2块有C[k-n,n]*2^n种方法，对于k*3的格子，至少放0个2*2块，至多放k/2个2*2块，因此各项累加就能得到最后的答案，值得注意的就是编写计算组合公式的时候要考虑好数据范围，当然这道题数据范围不是问题。
其中关于C[k-n,n]是在1*k的方块中选择n个不相交的1*2方块，可理解为在k-n个1*1方块中选择n个变为1*2方块。

**递推一**:
F[n] = F[n-1] + 2*F[n-2]
递推式解释：对于n*3的格子,其铺设方案要么是在(n-1)*3的格子的基础上加1*3个格子，在1*3的格子上铺设方案有1种，要么是在(n-2)*3的格子基础上加2*3个格子，在2*3个格子上铺设方案有3种，但因为用6个1*1块铺设所构成的整体方案其实已经算在(n-1)*3的格子上加1*3格子的方案中了，因此有效方案只有2种。所以得到如上的递推式。

**递推二**:
F[n] = 2*F[n-1] + (-1)^n
关于这个公式，是在看到了一些数之后猜出来的，并且在一段时间内既没有找到合理的形象解释，也没有合理的推导(事后，发现我绝对是脑子短路了~！)
其实,
F[n] = 2*F[n-1] +(-1)^n
F[n-1] = 2*F[n-2] +(-1)^(n-1)
左右相加得：F[n] = F[n-1] + 2*F[n-2] + 0
这不就是之前那个递推式么...不过这个形式比较容易推导出通项公式。

其通项公式计算过程(中学阶段的方法)为：
F[n+1] = 2*F[n] - (-1)^n
等式两边同除(-1)^(n+1)得
F[n+1]/(-1)^(n+1) = (-2)*F[n]/(-1)^(n+1) + 1
令T[n] = F[n]/(-1)^n得
T[n+1] = (-2)*T[n] + 1
此等式必然符合 T[n+1]+k = (-2)*(T[n]+k)
解得k = - 1/3
即T[n]-1/3是以-2为距离的等比数列
将F[n]回代T[n]得通项公式(化简后) F[n] = [(-1)^n + 2^(n+1)] / 3

# 我的代码--排列组合版本

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

unsigned long long J2[30] = {0};

/*V中选N个*/
unsigned long long C(int v,int n)
{
	unsigned long long res = 1;
	if(n==0) return 1;
	for(int i=0; i&lt;n; ++i)
	{
		res *= v-i;
	}
	for(int i=2; i&lt;=n; ++i)
	{
		res /= i;
	}
	return res;
}
void calc2()
{
	J2[0] = 1;
	for(int i=1; i&lt;30; ++i)
	{
		J2[i] = J2[i-1] * 2;
	}
}

int main()
{
	int k,T;
	calc2();
	cin &gt;&gt; T;
	while(T--)
	{
		unsigned long long res = 1;
		cin &gt;&gt; k;
		for(int i=1; i&lt;=k/2; ++i)
			res += C(k-i,i)*J2[i];
		cout &lt;&lt; res &lt;&lt; endl;
	}
	return 0;
}
[/code]

# 我的代码--递推版本

[code lang="cpp"]
#include &lt;iostream&gt;
using namespace std;

int main(void)
{
    int n;
    int m;
    int a[31];
    a[1] = 1;
    a[2] = 3;
    for(n=3; n&lt;31; ++n)
        a[n] = a[n-1] + 2*a[n-2];
    cin &gt;&gt; n;
    while(n--)
    {
        cin &gt;&gt; m;
        cout &lt;&lt; a[m] &lt;&lt; endl;
    }
    return 0;
}
[/code]
[/toggle]

[toggle title="第六题题解"]

# 解题思路

约瑟夫环问题。
这里直接模拟,没什么好说的，实现的话，可以采用数组的方式（出列的做好标记，下次到来直接跳过，数组末尾再回到头部，如此循环即可）和链表的方式（将每个结点先记录自己的编号，随后直接删除即可，到链表尾再回到链表头部，如此循环即可，当然采用循环链表避免自己对指针的控制就更好了）。（后面我的代码中实现了数组和循环链表的方案。）

# 我的代码--数组版本

[code lang="cpp"]
#include &lt;iostream&gt;

using namespace std;
int A[10000] = {0};
int main(void)
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    int t = n;
    int p = 1;//下一个人
    int num = 1;//将要报的数字
    while(t)
    {
        while(A[p])
        {
            if(p == n)
                p = 1;
            else
                ++p;
        } 
        //报数字
        if(num == m)
        {
            //出列
            cout &lt;&lt; p &lt;&lt; &quot; &quot;;
            A[p] = 1;
            --t;
            num = 1;
        }
        else
            ++num;

        if(p == n)
            p = 1;
        else
            ++p;
    }
    return 0;
}
[/code]

# 我的代码--循环链表版本

[code lang="cpp"]
#include &lt;iostream&gt;
using namespace std;
struct T
{
    int id;
    T* next;
};

T* build(int n)
{
    if(n==0) return NULL;
    T* head = new T;
    head-&gt;id = 1;
    head-&gt;next = NULL;
    T* p = head;
    for(int i=2; i&lt;=n; ++i)
    {
        p-&gt;next = new T;
        p = p-&gt;next;
        p-&gt;id = i;
        p-&gt;next = NULL;
    }
    p-&gt;next = head;
    return head;
}

T* erase_next(T* node)
{
    T* t = node-&gt;next-&gt;next;
    if(node-&gt;next != node)
    {
        delete node-&gt;next;
        node-&gt;next = t;
        return node;
    }
    else
    {
        delete node;
        return NULL;
    }
}

int main(void)
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    T* head = build(n);
    T* p = head;
    int num=1;
    while(1)
    {
        if(num == m)
        {
            num = 1;
        }
        else
        {
            ++num;
            if(num == m)
            {
                cout &lt;&lt; p-&gt;next-&gt;id &lt;&lt; &quot; &quot;;
                p = erase_next(p);
                if(p == NULL) break;
            }
            p = p-&gt;next;
        }
    }
    return 0;
}
[/code]
[/toggle]

[toggle title="第七题题解"]

# 解题思路

k个人，那么将会分成v=(k-1)/8+1组(这个公式是k/8.0向上取整纯整数版本，算是一个小技巧吧)。
k个人分成v组,每组的人数是k/v或者k/v+1。因为不可能出现人数互相不同的三个组，试想一下，假如出现了，为什么不从最大的组抽人给最小的组呢。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

int main()
{
	int k;
	cin &gt;&gt; k;
	int dv = (k-1)/8+1;
	if(k%dv)
	{
		for(int i=0; i&lt;k%dv; ++i)
			cout &lt;&lt; k/dv+1 &lt;&lt; endl;
		for(int i=k%dv; i&lt;dv; ++i)
			cout &lt;&lt; k/dv &lt;&lt; endl;
	}
	else
	{
		for(int i=0; i&lt;dv; ++i)
			cout &lt;&lt; k/dv &lt;&lt; endl;
	}
	return 0;
}
[/code]
[/toggle]

[toggle title="第八题题解"]

# 解题思路

开辟一个二维数组，这就相当于是在绘图。据规律绘制即可。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
int A[110][110] = {0};
int main()
{
	int n;
	cin &gt;&gt; n;
	for(int k=0; k&lt;n/2+1; k=k+2)
	{
		for(int i=k; i&lt;n-k; ++i)
		{
			A[i][k] = 1;
			A[i][n-k-1] = 1;
		}
		for(int j=k; j&lt;n-k; ++j)
		{
			A[k][j] = 1;
			A[n-k-1][j] = 1;
		}
	}
	for(int i=0; i&lt;n; ++i)
	{
		for(int j=0; j&lt;n; ++j)
			if(A[i][j])
				cout &lt;&lt; '*';
			else
				cout &lt;&lt; ' ';
		cout &lt;&lt; endl;
	}
	return 0;
}
[/code]
[/toggle]

[toggle title="第九题题解"]

# 解题思路

纯模拟。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

int main()
{
	char str[211];
	char res[600];
	gets(str);
	int pn = 0;
	int len = strlen(str);
	for(int i=0; i&lt;len; ++i)
	{
		if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z')//is word
		{
			if(i==0 || (i&gt;0 &amp;&amp; str[i-1]==' '))
				res[pn++] = str[i]-'a'+'A';
			else
				res[pn++] = str[i];
		}
		if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')
		{
			if(i&gt;0 &amp;&amp; str[i-1]&gt;='a' &amp;&amp; str[i-1]&lt;='z')
				res[pn++] = '_';
			res[pn++] = str[i];
			if(i&lt;len-1 &amp;&amp; str[i+1]&gt;='a' &amp;&amp; str[i+1]&lt;='z')
				res[pn++] = '_';
		}
		if(str[i]==' ')
		{
			if(i&gt;0 &amp;&amp; str[i-1] != ' ')
				res[pn++] = ' ';
		}
	}
	res[pn] = '&#92;&#48;';
	cout &lt;&lt; res &lt;&lt; endl;
	return 0;
}
[/code]
[/toggle]

[toggle title="第十题题解"]

# 解题思路

预处理一个素数表，然后枚举一对素数，计算出其中的距离，然后让较大的素数加上这段距离得到一个新的数，判断这个新的数是否还在范围内并且是素数（期间随时保存当前发现的最长等差素数组）。

# 我的代码

[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;

vector&lt;int&gt; v;
vector&lt;int&gt; link;
int flag[2000] = {0};

void def(int l,int r)
{
	v.clear();
	for(int i=2; i&lt;r; ++i)
	{
		int is_prime = 1;
		for(int k=0; k!=v.size(); ++k)
		{
			if(i%v[k] == 0)
			{
				is_prime = 0;
				break;
			}
		}
		if(is_prime)
			v.push_back(i);
	}
}

int main()
{
	int l = 100, r = 1000;
	int max_len = 2;
	def(l,r);
	for(int i=0; i!=v.size(); ++i)
		flag[v[i]] = 1;
	for(int i=0; i!=v.size(); ++i)
	{
		for(int j=i; j!=v.size(); ++j)
		{
			if(i==j) continue;
			int len = 2;
			int ok = 1;
			int tex = v[j]-v[i];
			int lt = v[j];
			while(ok &amp;&amp; lt&lt;=r)
			{
				if(flag[lt+tex])
				{
					++len;
					if(len &gt; max_len)
					{
						max_len = len;
						link.clear();
						for(int k=0; k&lt;len; ++k)
							link.push_back(v[i]+k*tex);
					}
					lt = lt+tex;
				}
				else
					ok = 0;
			}
		}
	}
	cout &lt;&lt; max_len &lt;&lt; endl;
	for(int i=0; i!=link.size(); ++i)
		cout &lt;&lt; link[i] &lt;&lt; &quot; &quot;;
	return 0;
}
[/code]
[/toggle]

# 题目及源码下载

*   [download link="http://www.aemiot.com/download/acmteam-2014-001exm.rar"]<span style="color: #050505;"><big><b>&nbsp;&nbsp;&nbsp;本地下载**</big></span>[/download]

[warning]
作者:Aem
本文版权归作者和www.aemiot.com共有，未征得作者本人同意之前，请勿将本文内容用于任何商业用途。 欢迎非商业用途转载，但请在明显位置注明本文作者和出处链接，否则我们保留追究法律责任的权利。
[/warning]