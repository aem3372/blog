title: '动态规划|LCS(最长公共子序列)|Common Subsequence|HDU-1159'
tags:
  - DP
  - LCS
id: 1317
categories:
  - 算法/数据结构
date: 2014-03-21 15:51:54
---

# 题目

[Common Subsequence](http://acm.hdu.edu.cn/showproblem.php?pid=1159 "http://acm.hdu.edu.cn/showproblem.php?pid=1159")

# 题目描述

A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = <x1, x2, ..., xm> another sequence Z = <z1, z2, ..., zk> is a subsequence of X if there exists a strictly increasing sequence <i1, i2, ..., ik> of indices of X such that for all j = 1,2,...,k, xij = zj. For example, Z = <a, b, f, c> is a subsequence of X = <a, b, c, f, b, c> with index sequence <1, 2, 4, 6>. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. 
The program input is from a text file. Each data set in the file contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. 

# Input

RT

# Output

RT

# Sample Input 1

abcfbc abfcab
programming contest 
abcd mnp

# Sample Output 1

4
2
0

# Source

Southeastern Europe 2003

# 题目大意

求连个串的LCS（最长公共子序列，可以不连续）。

# 解题思路

典型动归问题。动归方程见代码注释。

# 我的代码

[code lang="cpp"]
//长度为i j的a b的子串动归
//DP[i,j] = {
//        DP[i-1][j-1]+1 ,while Ai == Aj
//        max{DP[i-1][j],DP[i][j-1]} while Ai != Aj
//}

//0 0 0 0 0
//0 - - - -
//0 - - - -
//0 - - - -
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#define max(a,b) ((a)&gt;(b)?(a):(b))
using namespace std;
int DP[1000][1000];
int main()
{
    string a,b;
    while(cin &gt;&gt; a &gt;&gt; b)
    {
        memset(DP,0,sizeof(DP));
        for(int i=1; i&lt;=a.size(); ++i)
            for(int j=1; j&lt;=b.size(); ++j)
            {
                if(a[i-1] == b[j-1])
                    DP[i][j] = DP[i-1][j-1] + 1;
                else
                    DP[i][j] = max(DP[i-1][j],DP[i][j-1]);
            }
        cout &lt;&lt; DP[a.size()][b.size()] &lt;&lt; endl;
    }
    return 0;
}
[/code]

[warning]
作者:Aem
本文版权归作者和www.aemiot.com共有，未征得作者本人同意之前，请勿将本文内容用于任何商业用途。 欢迎非商业用途转载，但请在明显位置注明本文作者和出处链接，否则我们保留追究法律责任的权利。
[/warning]